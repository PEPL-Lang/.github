# PEPL — pepl-lang

## Identity

| Field | Value |
|-------|-------|
| Organization | `pepl-lang` (GitHub org) |
| Repositories | `pepl` (compiler + spec), `pepl-stdlib` (standard library), `pepl-ui` (UI component model) |
| Visibility | Public (all three repos) |
| Purpose | A deterministic, sandboxed language for building interactive applications (spaces) — **designed for LLM code generation, not human authoring**. Type-safe, keyword-based syntax optimized for LLM token efficiency, compiles to WASM |

Three repos in one canvas because they are co-developed, co-versioned, and tightly coupled. A change to the language spec typically implies stdlib and UI changes. They ship as a unit.

PEPL is an **LLM-first language**. It is designed to be generated by language models, not written by human programmers. Every syntax decision — keyword-based control flow (`not` instead of `!`), explicit `set` for mutations, mandatory type annotations on state — exists because it reduces LLM generation errors. Humans CAN read and write PEPL, but that is a secondary use case. See `llm-generation-contract.md` for the full generation protocol.

## What It Builds

**`pepl` repo** — The compiler and language specification:
- PEPL parser (source → AST)
- Type checker (AST → typed AST)
- Invariant checker (verified AST)
- WASM code generator (AST → .wasm binary)
- Gas metering injector
- Written in Rust, compiled to WASM (runs in browser Web Worker)

**`pepl-stdlib` repo** — The standard library:
- Core modules (always available): `core`, `math`, `string`, `list`, `record`, `time`, `convert`, `json`, `timer`
- Capability modules (require host support): `http`, `storage`, `location`, `notifications`
- All core functions deterministic, all execute in < 1ms
- Capability functions yield to host for I/O (deterministic on replay)
- Immutable API: released functions never change behavior

**`pepl-ui` repo** — The UI component model:
- Platform-abstract component definitions (layout, content, interactive, list, navigation, feedback, canvas, chart)
- Animation system (declarative, deterministic)
- Accessibility primitives (labels, hints, roles, live regions)
- Components compile to browser DOM in Phase 0; future platforms provide native renderers

### Scope Boundary

**Inside these repos**: Language specification, compiler implementation, stdlib functions, UI component definitions, compilation pipeline, error messages, gas metering strategy.

**Outside these repos**: How UI components are rendered to DOM (that's the host application's View Layer), how WASM is executed (that's the WASM sandbox), how spaces are created/managed (that's the host application), LLM prompt engineering about PEPL (that's the host's integration layer).

## Guarantees

### Determinism
- Same PEPL source + same inputs MUST produce identical outputs
- No ambient state access (time, random — must be injected via controlled sources)
- WASM compilation is reproducible (same source → same bytecode)

### Safety
- PEPL programs MUST NOT access host memory or filesystem directly
- All external I/O (network, storage, sensors) is through declared capabilities — the host mediates all requests
- Buffer overflows are impossible (bounds-checked arrays)
- Infinite loops are prevented (gas metering in WASM)

### Transformation
- Any valid PEPL program can be transformed into any other valid PEPL program
- Transformation preserves type safety (old → new must both compile)
- Transformations produce meaningful diffs (AST-level, not line-level)

### Type Safety
- All type errors caught at compile time (no runtime type errors)
- No implicit type coercion
- Null safety via explicit `nil` handling

### Stdlib Stability
- Stdlib functions NEVER change behavior once released
- New functions MAY be added; existing functions are NEVER removed or modified
- Deprecated functions continue working but emit compiler warnings

### UI Completeness
- UI component library covers all platform-abstract visual patterns
- Every component has built-in accessibility support
- Missing functionality is explicitly documented as "not yet available"

## Invariants

- Every PEPL program defines exactly one space
- Every space has at least one `state` block and one `view` function
- State is only modified through `action` declarations or `derived` block computations (no direct mutation)
- All state transitions are observable by the host (for event logging, replay, etc.)
- UI components are platform-abstract (never reference specific DOM/native APIs)
- Every stdlib function executes in < 1ms
- UI components render in < 16ms (60fps budget)
- All I/O is host-mediated — PEPL code never performs I/O directly
- Block ordering is enforced by the grammar: `types → state → capabilities → credentials → derived → invariants → actions → views → update → handleEvent`
- Derived state recomputes automatically after every action — derived fields are read-only
- Credentials are compile-time declarations in the `credentials {}` block — never magic strings
- Tests live in a separate `tests {}` block outside `space {}` — never inside the space
- Only `//` single-line comments — no block comments

## Explicit Non-Goals

- Does NOT provide direct network access (all I/O is host-mediated via capabilities)
- Does NOT support concurrency or parallelism (single-threaded execution)
- Does NOT provide dynamic code evaluation (no `eval`)
- Does NOT support importing external packages (only stdlib + capabilities)
- Does NOT define how UI is rendered (that's the host application's View Layer)
- Does NOT manage space lifecycle (that's the host application's job)
- Does NOT implement its own rendering (abstract surfaces → platform renders)
