# LLM Generation Contract

PEPL is an **LLM-first language** — designed to be generated by language models, not written by human programmers. Every syntax decision exists because it reduces LLM generation errors:

| Design Choice | Why It Helps LLMs |
|---|---|
| Keyword-based control flow (`not`, `and`, `or`) | Tokenizes cleanly — no ambiguous symbols like `!`, `&&`, `\|\|` |
| Explicit `set` for mutations | LLMs never accidentally produce bare assignments |
| Mandatory type annotations on state | Eliminates type inference errors in generation |
| `match` with exhaustiveness checking | Compiler catches missing cases — LLM doesn't need to remember all variants |
| Flat structure (state/action/view blocks) | Predictable skeleton — LLMs generate one block at a time |
| No imports, no file system | Zero boilerplate — every space is self-contained |
| Small keyword set (39 reserved words) | Fits in LLM working memory without confusion |
| Deterministic semantics | LLM can reason about program behavior without runtime surprises |

## LLM Context Injection Protocol

Every LLM prompt that generates PEPL MUST inject this context:

1. **Compressed PEPL Reference** (~2K tokens) — see below
2. **Phase 0 Stdlib Table** — full function signatures from this spec
3. **Target space source** (if evolving an existing space)
4. **User's natural language intent**

Total PEPL context budget: **~4K tokens**. The remaining context window is for intent, conversation history, and LLM reasoning.

```
[System prompt structure]
You generate PEPL code. PEPL is a deterministic language that compiles to WASM.
{compressed_pepl_reference}
{phase_0_stdlib_table}
{existing_space_source OR "Create a new space."}
User intent: {user_intent}
```

## Generation Patterns (DO)

LLMs MUST follow these patterns when generating PEPL:

1. **Follow block ordering**: types→state→capabilities→credentials→derived→invariants→actions→views (compiler enforced)
2. **Use explicit `set`** for every state mutation — never bare assignment
3. **Prefer `match` over nested `if/else`** for 3+ branches
4. **Use stdlib functions** over manual computation (`math.clamp` not `if x > max then max else...`)
5. **Declare capabilities before using them** — the `capabilities {}` block comes after `state {}`
6. **Always type state fields** — `count: number = 0`, never `count = 0`
7. **Handle `Result` with `match` or `?`** — never assume http/storage calls succeed
8. **Use `credentials {}` block** for API keys — never embed secrets in source
9. **Keep views pure** — no `set` inside view functions, only in actions
10. **Use `json.parse` for http response bodies** — they're always strings
11. **Use record-style component syntax** — `Button { label: "text", on_tap: action_name }`, never function-call style
12. **Use `${expr}` for string interpolation** — `"Count: ${count}"`, not `"Count: " + convert.to_string(count)`
13. **Use `derived {}` for computed state** — never recompute in views or actions
14. **Use record spread** for immutable updates — `{ ...old, field: new_value }`
15. **Use `?` for Result chaining** — `let data = http.get(url)?` unwraps Ok, traps on Err
16. **Use `??` for nil defaults** — `let name = value ?? "default"`
17. **Use `for item, index in list`** when index is needed — not manual counter
18. **Use `return` for early exit** from actions when guard conditions fail — all prior `set` statements are applied

## Anti-Patterns (NEVER)

LLMs MUST NOT generate these:

| Anti-Pattern | Why It Fails | Correct Pattern |
|---|---|---|
| `count = count + 1` | Missing `set` keyword | `set count = count + 1` |
| `let x = http.get(url)` in view | Side effect in view | Move to action, store in state |
| `api_key = "sk-..."` | Secret in source code | Declare in `credentials {}` block |
| `while true { ... }` | No `while` in PEPL | Use `for` with bounded list |
| `view main() { ... }` | Missing `-> Surface` | `view main() -> Surface { ... }` |
| `import math` | No imports in PEPL | Stdlib is always available |
| Nested `if/else` (4+ levels) | Hard to read, error-prone | Use `match` with sum types |
| `set items = response.body` | http returns `Result`, not direct value | `match response { Ok(r) -> { ... } Err(e) -> { ... } }` |
| `Button("label", on_tap: action)` | Wrong syntax | `Button { label: "label", on_tap: action_name }` |
| `"Hello {name}"` | Wrong interpolation | `"Hello ${name}"` |
| `/* block comment */` | No block comments | `// line comment only` |
| `fn(x) -> x * 2` | No expression-body lambdas | `fn(x) { x * 2 }` |
| `record<{ a: number }>` | Removed syntax | `{ a: number }` |
| `let t: timestamp = time.now()` | No timestamp type | `let t: number = time.now()` |
| `core.eq(a, b)` | Operator duplicate removed | `a == b` |
| `math.add(a, b)` | Operator duplicate removed | `a + b` |
| `set derived_field = ...` | Cannot set derived fields | Derived fields are auto-computed |
| `credential("key")` | No runtime credential function | Declare in `credentials {}` block |

## Validation Checklist (LLM Self-Check)

Before outputting PEPL, the LLM SHOULD verify:

- [ ] Block ordering: types→state→capabilities→credentials→derived→invariants→actions→views
- [ ] Every `set` targets a field declared in `state {}`
- [ ] No `set` targeting a `derived {}` field
- [ ] Every action referenced in UI (`on_tap:`, `on_change:`) is declared as an `action`
- [ ] All used capabilities are declared in `capabilities {}`
- [ ] All API keys/secrets declared in `credentials {}`, never in source
- [ ] Every `match` covers all variants (or includes `_` wildcard)
- [ ] Types are consistent (no `set count = "hello"` when `count: number`)
- [ ] The view tree is valid (one root Surface, only recognized Phase 0 components)
- [ ] All components use record-style syntax: `Component { prop: value }`
- [ ] String interpolation uses `${expr}`, not `{expr}`
- [ ] `Result` values from http/storage are handled with `match` or `?`
- [ ] State fields all have type annotations and default values
- [ ] Only `//` comments used (no `/* */`)
- [ ] Lambdas use block body only: `fn(x) { x * 2 }`, not `fn(x) -> x * 2`
- [ ] No `timestamp`, `duration`, or `record<{}>` types used

## Error Recovery Protocol

When generated PEPL fails compilation, the compiler returns structured JSON errors:

```json
{
  "errors": [
    {"code": "E101", "line": 5, "column": 3, "message": "Unknown state field 'items'. Did you mean to declare it in state {}?"}
  ]
}
```

The LLM reads the error, fixes the specific issue, and regenerates. Common fix patterns:

| Error Code | Meaning | LLM Fix |
|---|---|---|
| E101 | Unknown identifier | Add missing state field or check spelling |
| E201 | Type mismatch | Change value type or state field type |
| E210 | Non-exhaustive match | Add missing variant or `_` wildcard |
| E301 | Invariant references unknown field | Fix field name in invariant expression |
| E402 | Unknown component | Replace with Phase 0 component |
| E501 | `set` outside action / capability used in view | Move `set` into action body; move capability call out of view |

## Compressed PEPL Reference (~2K tokens)

> This exact text is injected into every LLM prompt that generates PEPL. It is the minimum context needed for correct generation.

```
PEPL: deterministic, sandboxed language. Compiles to WASM. One space per file.
Comments: // only (no block comments)

STRUCTURE (block order enforced):
  space Name {
    types      { type X = | A | B(field: type) }
    state      { field: type = default }
    capabilities { required: [http, storage] optional: [location] }
    credentials  { api_key: string }
    derived    { full_name: string = "${first} ${last}" }
    invariants { name { bool_expression } }
    actions    { action name(p: type) { set field = value } }
    views      { view main() -> Surface { Column { Text { value: "hi" } } } }
    update(dt: number) { ... }             // optional — game/animation loop
    handleEvent(event: InputEvent) { ... } // optional — game/interactive input
  }
  // Tests go OUTSIDE the space:
  tests { test "name" { assert expression } }

TYPES: number, string, bool, nil, color
  number covers integers, floats, AND timestamps/durations (Unix ms)
  No timestamp or duration types — use number
COMPOSITES: list<T>, { field: type }
  No record<{}> — use { field: type } inline
SUM TYPES: type Name = | Variant1(field: type) | Variant2
RESULT: type Result<T, E> = | Ok(value: T) | Err(error: E)
  No user-defined generics — only built-in list<T>, Result<T,E>

CONTROL FLOW:
  if cond { ... } else { ... }
  for item in list { ... }
  for item, index in list { ... }        // optional index binding
  match expr { Pattern(bind) -> result, _ -> default }
  let name: type = expression             // immutable binding
  set field = expression                  // state mutation (actions only)
  set record.field = expression            // sugar for { ...record, field: expr }
  return                                  // early exit from action (no value)

OPERATORS:
  Arithmetic: + - * / %
  Comparison: == != < > <= >=
  Logical: not and or
  Result unwrap: expr?                    // postfix — traps on Err
  Nil-coalescing: expr ?? fallback
  Record spread: { ...base, field: val }

NIL NARROWING:
  if x != nil { ... }                    // x narrows from T|nil to T in block
  let item = list.get(items, i) ?? fallback  // also valid

STRING INTERPOLATION: "Hello ${name}, you have ${count} items"

LAMBDAS (block-body only):
  fn(x) { x * 2 }                        // no expression-body shorthand
  Return value = last expression in block body. No `return` in lambdas.
  match can be used as expression or standalone statement.

STDLIB (always available, no imports):
  core: log, assert, type_of, capability
  math: abs, min, max, floor, ceil, round, round_to, pow, clamp, sqrt, PI, E
  string: length, concat, contains, slice, trim, split, to_upper, to_lower,
          starts_with, ends_with, replace (first), replace_all, pad_start, pad_end,
          repeat, join, format, from, is_empty, index_of
  list: length, append, prepend, get (nil on OOB), set, insert, remove, update,
        map, filter, sort, find, find_index, contains, reverse, slice, flatten,
        reduce, range, of, empty, repeat, concat, unique, take, drop,
        any, some, every, count, first, last, index_of, zip
  record: get, set, has, keys, values
  time: now, format, diff, day_of_week, start_of_day
  convert: to_string, to_number, to_bool, parse_int, parse_float
           // parse_int, parse_float return Result<number, ConvertError>
  json: parse(string -> Result<any, JsonError>), stringify(any -> string)
  timer: start(action_name, interval_ms) -> id, start_once(action_name, delay_ms) -> id,
         stop(id), stop_all()

  No operator duplicates (no core.eq, math.add, etc.)
  string.replace replaces FIRST occurrence only — use string.replace_all for all

CAPABILITIES (require declaration + host support):
  http: get, post, put, patch, delete — all return Result<HttpResponse, HttpError>
        options: { headers: [...], timeout: number, content_type: string }
  storage: get, set, delete, keys — all return Result<T, StorageError>

CREDENTIALS:
  Declared in credentials {} block — host prompts user, injects at runtime
  Access: api_key is a read-only binding in the space — NEVER put API keys in source

UI COMPONENTS (record-style syntax):
  Layout: Column { ... }, Row { ... }, Scroll { ... }
  Content: Text { value: expr }, ProgressBar { value: 0.0-1.0 }
  Interactive: Button { label: expr, on_tap: action_name }
               TextInput { value: expr, on_change: action_name, placeholder: expr }
  Data: ScrollList { items: expr, render: fn(item, index) { Component { ... } } }
  Feedback: Modal { visible: bool, on_dismiss: action_name }, Toast { message: expr }
  Conditional: if cond { Component { ... } }
  List: for item in items { Component { ... } }

RULES:
  - Block order enforced: types→state→capabilities→credentials→derived→invariants→actions→views→update→handleEvent
  - All state mutations use 'set' keyword, only inside actions
  - Views are pure — no side effects, no set
  - match must be exhaustive (cover all variants or use _)
  - No imports, no file system, no globals — everything is in the space
  - http responses are Result — always match Ok/Err or use ?
  - tests {} block goes OUTSIDE the space, not inside
  - Module names (math, core, time, etc.) are reserved — cannot shadow them
  - list.of is special-cased variadic — no general variadic functions
```

## Canonical Examples

> Complete, compilable spaces demonstrating the full language surface. Each example is a valid Phase 0 space.

### Counter (minimal space)

```pepl
// Demonstrates: state, action, view, set, Button, Text
space Counter {
  state {
    count: number = 0
  }

  action increment() {
    set count = count + 1
  }

  action decrement() {
    set count = math.max(0, count - 1)
  }

  view main() -> Surface {
    Column {
      Text { value: "Count: ${count}" }
      Row {
        Button { label: "−", on_tap: decrement }
        Button { label: "+", on_tap: increment }
      }
    }
  }
}
```

### Todo List

```pepl
// Demonstrates: list<record>, for loop, TextInput, on_change, conditional rendering
space TodoList {
  state {
    todos: list<{ text: string, done: bool }> = []
    input: string = ""
  }

  action update_input(value: string) {
    set input = value
  }

  action add_todo() {
    if string.length(input) > 0 {
      set todos = list.append(todos, { text: input, done: false })
      set input = ""
    }
  }

  action toggle(index: number) {
    let todo = list.get(todos, index)
    if todo != nil {
      set todos = list.set(todos, index, { ...todo, done: not todo.done })
    }
  }

  view main() -> Surface {
    Column {
      TextInput { value: input, on_change: update_input, placeholder: "Add a todo..." }
      Button { label: "Add", on_tap: add_todo }
      for todo, index in todos {
        Row {
          Text { value: if todo.done { "✓ " } else { "○ " } }
          Text { value: todo.text }
          Button { label: "Toggle", on_tap: toggle(index) }
        }
      }
      Text { value: "${list.length(list.filter(todos, fn(t) { not t.done }))} remaining" }
    }
  }
}
```

### Unit Converter

```pepl
// Demonstrates: match, Result handling, math operations, multiple conversions
space UnitConverter {
  state {
    value: number = 0
  }

  action set_value(v: string) {
    match convert.parse_float(v) {
      Ok(n) -> set value = n
      Err(_) -> { }
    }
  }

  view main() -> Surface {
    Column {
      TextInput { value: convert.to_string(value), on_change: set_value, placeholder: "Enter value" }
      Text { value: "km → miles: ${math.round_to(value * 0.621371, 2)}" }
      Text { value: "miles → km: ${math.round_to(value * 1.60934, 2)}" }
      Text { value: "°C → °F: ${math.round_to(value * 9 / 5 + 32, 1)}" }
      Text { value: "°F → °C: ${math.round_to((value - 32) * 5 / 9, 1)}" }
    }
  }
}
```

### Weather Dashboard (http + json + credential)

```pepl
// Demonstrates: http capability, json.parse, credentials block, Result handling, error state
space WeatherDashboard {
  state {
    city: string = "London"
    temperature: string = "--"
    description: string = "Enter a city and tap Search"
    loading: bool = false
    error_message: string = ""
  }

  capabilities {
    required: [display, keyboard_or_touch, http]
  }

  credentials {
    weather_api_key: string
  }

  action update_city(value: string) {
    set city = value
  }

  action fetch_weather() {
    set loading = true
    set error_message = ""
    let response = http.get(
      "https://api.weather.dev/v1/current?city=${city}",
      { headers: [{ key: "Authorization", value: "Bearer ${weather_api_key}" }] }
    )
    match response {
      Ok(r) -> {
        let data = json.parse(r.body)
        match data {
          Ok(parsed) -> {
            set temperature = "${record.get(parsed, \"temp\")}°C"
            set description = record.get(parsed, "description")
          }
          Err(e) -> { set error_message = "Invalid response format" }
        }
      }
      Err(e) -> { set error_message = e.message }
    }
    set loading = false
  }

  view main() -> Surface {
    Column {
      Text { value: "Weather Dashboard" }
      Row {
        TextInput { value: city, on_change: update_city, placeholder: "City name" }
        Button { label: "Search", on_tap: fetch_weather }
      }
      if loading {
        Text { value: "Loading..." }
      }
      if string.length(error_message) > 0 {
        Text { value: "Error: ${error_message}" }
      }
      if not loading {
        Text { value: temperature }
        Text { value: description }
      }
    }
  }
}
```

### Pomodoro Timer

```pepl
// Demonstrates: timer module, state machine, Modal, string formatting
space PomodoroTimer {
  state {
    mode: string = "idle"
    seconds_left: number = 1500
    total_pomodoros: number = 0
    timer_id: string = ""
  }

  action start_work() {
    timer.stop_all()
    set mode = "work"
    set seconds_left = 1500
    set timer_id = timer.start("tick", 1000)
  }

  action start_break() {
    timer.stop_all()
    set mode = "break"
    set seconds_left = 300
    set timer_id = timer.start("tick", 1000)
  }

  action tick() {
    if seconds_left > 0 {
      set seconds_left = seconds_left - 1
    } else {
      timer.stop(timer_id)
      if mode == "work" {
        set total_pomodoros = total_pomodoros + 1
        set mode = "done_work"
      } else {
        set mode = "idle"
      }
    }
  }

  action reset() {
    timer.stop_all()
    set mode = "idle"
    set seconds_left = 1500
  }

  view main() -> Surface {
    Column {
      Text { value: "Pomodoro Timer" }
      Text { value: "${math.floor(seconds_left / 60)}:${string.pad_start(convert.to_string(seconds_left % 60), 2, \"0\")}" }
      Text { value: "Mode: ${mode}" }
      Row {
        Button { label: "Start Work", on_tap: start_work }
        Button { label: "Start Break", on_tap: start_break }
        Button { label: "Reset", on_tap: reset }
      }
      Text { value: "Completed: ${total_pomodoros} pomodoros" }
      Modal {
        visible: mode == "done_work",
        on_dismiss: start_break,
      } {
        Column {
          Text { value: "Work session complete!" }
          Button { label: "Take a break", on_tap: start_break }
        }
      }
    }
  }
}
```

### Habit Tracker (storage capability)

```pepl
// Demonstrates: storage capability, list of records, time operations
space HabitTracker {
  state {
    habits: list<{ name: string, streak: number, last_done: number }> = []
    new_habit: string = ""
  }

  capabilities {
    required: [display, keyboard_or_touch, storage]
  }

  action load_habits() {
    let result = storage.get("habits")
    match result {
      Ok(data) -> {
        let parsed = json.parse(data)
        match parsed {
          Ok(list) -> { set habits = list }
          Err(_) -> { set habits = [] }
        }
      }
      Err(_) -> { set habits = [] }
    }
  }

  action update_new_habit(value: string) {
    set new_habit = value
  }

  action add_habit() {
    if string.length(new_habit) > 0 {
      set habits = list.append(habits, { name: new_habit, streak: 0, last_done: 0 })
      set new_habit = ""
      let _ = storage.set("habits", json.stringify(habits))
    }
  }

  action mark_done(index: number) {
    let habit = list.get(habits, index)
    if habit != nil {
      let now = time.now()
      set habits = list.set(habits, index, { ...habit, streak: habit.streak + 1, last_done: now })
      let _ = storage.set("habits", json.stringify(habits))
    }
  }

  view main() -> Surface {
    Column {
      Text { value: "Habit Tracker" }
      Row {
        TextInput { value: new_habit, on_change: update_new_habit, placeholder: "New habit..." }
        Button { label: "Add", on_tap: add_habit }
      }
      for habit, index in habits {
        Row {
          Text { value: habit.name }
          Text { value: "Streak: ${habit.streak}" }
          Button { label: "Done today", on_tap: mark_done(index) }
        }
      }
    }
  }
}
```

### Quiz App

```pepl
// Demonstrates: sum types, pattern matching, score tracking, conditional UI
space QuizApp {
  state {
    current_question: number = 0
    score: number = 0
    answered: bool = false
    selected: string = ""
    questions: list<{ question: string, options: list<string>, correct: string }> = [
      { question: "What is 2 + 2?", options: ["3", "4", "5"], correct: "4" },
      { question: "Capital of France?", options: ["London", "Paris", "Berlin"], correct: "Paris" },
      { question: "Largest planet?", options: ["Earth", "Mars", "Jupiter"], correct: "Jupiter" }
    ]
  }

  action select_answer(answer: string) {
    set selected = answer
    set answered = true
    let q = list.get(questions, current_question)
    if q != nil {
      if answer == q.correct {
        set score = score + 1
      }
    }
  }

  action next_question() {
    set current_question = current_question + 1
    set answered = false
    set selected = ""
  }

  view main() -> Surface {
    Column {
      if current_question < list.length(questions) {
        let q = list.get(questions, current_question)
        if q != nil {
          Text { value: "Question ${current_question + 1} of ${list.length(questions)}" }
          Text { value: q.question }
          for option in q.options {
            Button { label: option, on_tap: select_answer(option) }
          }
          if answered {
            Text { value: if selected == q.correct { "Correct!" } else { "Wrong. Answer: ${q.correct}" } }
            Button { label: "Next", on_tap: next_question }
          }
        }
      } else {
        Text { value: "Quiz Complete!" }
        Text { value: "Score: ${score} / ${list.length(questions)}" }
      }
    }
  }
}
```
